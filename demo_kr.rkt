#lang scheme

(define (taskI lst)
  (cond ((null? lst) `())
        (else (caddr (foldl (lambda (cur res) (
                                        let ((i (car res)) (cur-min (cadr res)) (ans (caddr res)))
                                         (cond ((null? cur-min) (list (+ i 1) cur (list i)))
                                               ((< cur cur-min) (list (+ i 1) cur (list i)))
                                               ((= cur cur-min) (list (+ i 1) cur-min (cons i ans)))
                                               (else (list (+ i 1) cur-min ans))
                                               )
                                         )) (list 0 `() `()) lst)
                     )
              )
        )
  )

(define (taskII t s)
    (cond ((vector? t) (+
                           (taskII (vector-ref t 0) (/ s 4) )
                           (taskII (vector-ref t 1) (/ s 4) )
                           (taskII (vector-ref t 2) (/ s 4) )
                           (taskII (vector-ref t 3) (/ s 4) )
                           ))
          ((equal? t 1) s)
          (else 0)
          )
  )

(define (taskIII lst)
  (define max-length (foldl (lambda (curr res) (cond ((list? curr)
                                                  (let ((len (length curr)))
                                                    (if (> len res) len res)))
                                                 (else res))) 0 lst))
  (map (lambda (x) (if (and (list? x) (equal? (length x) max-length)) (map (lambda (y) (+ y 1)) x) x)) lst)
  )

; cc = (lambda (x) x)
; (taskIV-cc #(1 0 0 #(1 1 1 0)) 16 (lambda (x) x)) -> 7
(define (taskIV-cc t s cc)
  ; (lambda (y) (cc (+ y taskII taskII taskII taskII))
  ; (lambda (z) (cc (+ y z taskII taskII))
  ; (lambda (x) (cc (+ y z x taskII)))
  ; (lambda (w) (cc (+ y z x w)

    (cond ((vector? t)
           (taskIV-cc (vector-ref t 0) (/ s 4)
                      (lambda (y)
                        (taskIV-cc (vector-ref t 1) (/ s 4)
                                             (lambda (z)
                                               (taskIV-cc (vector-ref t 2) (/ s 4)
                                                                    (lambda (x)
                                                                      (taskIV-cc (vector-ref t 3) (/ s 4)
                                                                                 (lambda (w) (cc (+ x y z w)
                                                                                                 )
                                                                                   )
                                                                                 )
                                                                      )
                                                                    )
                                               )
                                             )
                        )
                      )
           )
          ((equal? t 1) (cc s))
          (else (cc 0))
          )
  )

(define (taskV . args)
  (let loop ((f (car args)) (tail (cdr args)))
    (if (null? tail)
        f
        (lambda (x) (f ((loop (car tail) (cdr tail)) x)))
        )
    )
  )